'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOptions = exports.createGetInitialState = exports.createWithStatesHocs = exports.createSetState = exports.createResetState = exports.createHandlers = exports.reducer = exports.RESET_STATE = exports.MERGE_STATE = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _recompose = require('recompose');

var _omitProps = require('./omitProps');

var _omitProps2 = _interopRequireDefault(_omitProps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MERGE_STATE = exports.MERGE_STATE = 'MERGE_STATE';
var RESET_STATE = exports.RESET_STATE = 'RESET_STATE';

var reducer = exports.reducer = function reducer(state) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      type = _ref.type,
      payload = _ref.payload;

  switch (type) {
    case MERGE_STATE:
      {
        return _extends({}, state, payload);
      }
    case RESET_STATE:
      {
        return _extends({}, payload);
      }
    default:
  }
  return state;
};

var createHandlers = exports.createHandlers = function createHandlers(stateKeys, dispatchName) {
  var handlers = {};
  stateKeys.forEach(function (stateKey) {
    var handler = function handler(_ref2) {
      var setState = _ref2[dispatchName];
      return function (value) {
        return setState({
          type: MERGE_STATE,
          payload: _defineProperty({}, stateKey, value)
        });
      };
    };
    handlers['set' + _lodash2.default.capitalize(stateKey)] = handler;
  });
  return handlers;
};

var createResetState = function createResetState(initialState, dispatchName) {
  return function (_ref3) {
    var dispatch = _ref3[dispatchName],
        props = _objectWithoutProperties(_ref3, [dispatchName]);

    return function () {
      var newState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
      return dispatch({
        type: RESET_STATE,
        payload: typeof newState === 'function' ? newState(props) : newState
      });
    };
  };
};

exports.createResetState = createResetState;
var createSetState = exports.createSetState = function createSetState(dispatchName) {
  return function (_ref4) {
    var dispatch = _ref4[dispatchName];
    return function (newState) {
      return dispatch({
        type: MERGE_STATE,
        payload: newState
      });
    };
  };
};

var createWithStatesHocs = exports.createWithStatesHocs = function createWithStatesHocs(initialState, _ref5) {
  var stateKeys = _ref5.stateKeys,
      _ref5$names = _ref5.names,
      stateName = _ref5$names.state,
      dispatchName = _ref5$names.dispatch,
      mergeName = _ref5$names.merge,
      resetName = _ref5$names.reset,
      omit = _ref5.omit;

  var handlers = createHandlers(stateKeys, dispatchName);
  handlers[resetName] = createResetState(initialState, dispatchName);
  handlers[mergeName] = createSetState(dispatchName);

  var hocs = [(0, _recompose.withReducer)(stateName, dispatchName, reducer, initialState), (0, _recompose.withHandlers)(handlers), (0, _recompose.flattenProp)(stateName)];

  var propsToOmit = _lodash2.default.keys(_lodash2.default.pickBy(omit, _lodash2.default.truthy));
  if (propsToOmit.length) {
    hocs.push((0, _omitProps2.default)(propsToOmit));
  }

  return hocs;
};

var createGetInitialState = exports.createGetInitialState = function createGetInitialState(initialKeysOrState) {
  var type = typeof initialKeysOrState === 'undefined' ? 'undefined' : _typeof(initialKeysOrState);
  if (type !== 'object' && type !== 'function') {
    throw new Error('initialKeysOrState must be an object or a function');
  }

  if (Array.isArray(initialKeysOrState)) {
    return {};
  }
  return initialKeysOrState;
};

var defaultOptions = {
  names: {
    state: 'state',
    dispatch: 'dispatchState',
    reset: 'resetState',
    merge: 'setState'
  },
  omit: {
    dispatch: true,
    state: true,
    reset: false,
    merge: false
  }
};

var createOptions = exports.createOptions = function createOptions(initialState) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var stateKeys = options.stateKeys;

  if (!stateKeys) {
    if (typeof initialState === 'function') {
      throw new Error('options.stateKeys must be specified when initialState is a function');
    }
    stateKeys = Array.isArray(initialState) ? initialState : Object.keys(initialState);
  }

  var mergedOptions = _lodash2.default.merge({}, defaultOptions, options);

  var omit = _lodash2.default.mapKeys(mergedOptions.omit, function (value, key) {
    return mergedOptions.names[key];
  });

  return _extends({}, mergedOptions, {
    stateKeys: stateKeys,
    omit: omit
  });
};

/*
 * Compatible for different params
 * withStates(
 *   initialKeys: Array<string> |
 *   initialState: {
 *     [stateKey: string]: initialValue: Any
 *   } |
 *   getInitialState: (props) => {
 *     [stateKey: string]: initialValue: Any
 *   },
 *   options: {
 *     stateName: string,
 *     dispatchName: string,
 *     stateKeys: Array<string>,
 *   },
 * )
 *
 * TODO: withStates(
 *   initialState: {
 *     [stateKey: string]: getInitialValue: Function
 *   },
 *   options: Object
 * )
 */

exports.default = function (initialKeysOrState, options) {
  var finalOptions = createOptions(initialKeysOrState, options);

  var initialState = createGetInitialState(initialKeysOrState, finalOptions);

  var hocs = createWithStatesHocs(initialState, finalOptions);

  return _recompose.compose.apply(undefined, _toConsumableArray(hocs));
};